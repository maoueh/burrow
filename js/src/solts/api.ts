import ts from 'typescript';
import { ABI } from './lib/abi';
import { Caller } from './lib/caller';
import { generateContractClass } from './lib/contract';
import { generateDecodeObject } from './lib/decoder';
import { generateDeployFunction } from './lib/deployer';
import { generateEncodeObject } from './lib/encoder';
import { Provider } from './lib/provider';
import { Replacer } from './lib/replacer';
import { getContractMethods } from './lib/solidity';
import { ExportToken, ImportReadable } from './lib/syntax';
import Func = ABI.Func;

export { decodeOutput, encodeInput, importLocal, inputDescriptionFromFiles, tokenizeLinks } from './lib/compile';

export type Compiled = {
  name: string;
  abi: ABI.FunctionOrEvent[];
  bin: string;
  links: Array<string>;
};

export function newFile(contracts: Compiled[]): ts.Node[] {
  const provider = new Provider();

  return [
    ts.addSyntheticLeadingComment(
      ImportReadable(),
      ts.SyntaxKind.SingleLineCommentTrivia,
      'Code generated by solts. DO NOT EDIT.',
    ),
    provider.createInterface(),
    Caller(provider),
    Replacer(),
    ...contracts.map((contract) => {
      const methods = getContractMethods(contract.abi);

      const deploy = contract.abi.find((abi): abi is Func => abi.type === 'constructor');

      // No deploy function for interfaces
      const deployFunction = contract.bin
        ? [generateDeployFunction(deploy, contract.bin, contract.links, provider)]
        : [];
      const statements = [
        ...deployFunction,
        generateContractClass(methods, provider),
        generateEncodeObject(methods, provider),
        generateDecodeObject(methods, provider),
      ];
      return ts.createModuleDeclaration(
        undefined,
        [ExportToken],
        ts.createIdentifier(contract.name),
        ts.createModuleBlock(statements),
      );
    }),
  ];
}

export function printNodes(...nodes: ts.Node[]): string {
  const target = ts.createSourceFile('', '', ts.ScriptTarget.Latest, false, ts.ScriptKind.TS);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  return nodes.map((node) => printer.printNode(ts.EmitHint.Unspecified, node, target)).join('\n');
}
