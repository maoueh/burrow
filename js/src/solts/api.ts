import ts from 'typescript';
import { ABI } from './lib/abi';
import { Caller } from './lib/caller';
import { Contract } from './lib/contract';
import { Decode } from './lib/decoder';
import { Deploy } from './lib/deployer';
import { Encode } from './lib/encoder';
import { Provider } from './lib/provider';
import { Replacer } from './lib/replacer';
import { GetContractMethods } from './lib/solidity';
import { ExportToken, ImportReadable } from './lib/syntax';

export { DecodeOutput, EncodeInput, ImportLocal, InputDescriptionFromFiles, TokenizeLinks } from './lib/compile';

export type Compiled = {
  name: string;
  abi: ABI.FunctionOrEvent[];
  bin: string;
  links: Array<string>;
};

export function NewFile(contracts: Compiled[]): ts.Node[] {
  const provider = new Provider();

  return [
    ts.addSyntheticLeadingComment(
      ImportReadable(),
      ts.SyntaxKind.SingleLineCommentTrivia,
      'Code generated by solts. DO NOT EDIT.',
    ),
    provider.createInterface(),
    Caller(provider),
    Replacer(),
    ...contracts.map((contract) => {
      const methods = GetContractMethods(contract.abi);

      let deploy: ABI.Func;
      contract.abi.map((abi) => {
        if (abi.type == 'constructor') {
          deploy = abi;
        }
      });

      return ts.createModuleDeclaration(
        undefined,
        [ExportToken],
        ts.createIdentifier(contract.name),
        ts.createModuleBlock([
          Deploy(deploy, contract.bin, contract.links, provider),
          Contract(methods, provider),
          Encode(methods, provider),
          Decode(methods, provider),
        ]),
      );
    }),
  ];
}

export function Print(...nodes: ts.Node[]) {
  const target = ts.createSourceFile('', '', ts.ScriptTarget.Latest, false, ts.ScriptKind.TS);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  return nodes.map((node) => printer.printNode(ts.EmitHint.Unspecified, node, target)).join('\n');
}
