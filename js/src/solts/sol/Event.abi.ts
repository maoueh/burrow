//Code generated by solts. DO NOT EDIT.
import { Address, BlockRange, CallTx, ContractCodec, EndOfStream, EventStream, LogEvent } from '../../index';
interface Provider {
  deploy(msg: CallTx): Promise<Address>;
  call(msg: CallTx): Promise<Uint8Array | undefined>;
  callSim(msg: CallTx): Promise<Uint8Array | undefined>;
  listen(
    signature: string,
    address: string,
    callback: (err?: Error | EndOfStream, log?: LogEvent) => void,
    range?: BlockRange,
  ): EventStream;
  payload(data: string | Uint8Array, address?: string): CallTx;
  contractCodec(contractABI: string): ContractCodec;
}
async function call<Output>(
  client: Provider,
  addr: string,
  data: Uint8Array,
  isSim: boolean,
  callback: (exec: Uint8Array | undefined) => Output,
): Promise<Output> {
  const payload = client.payload(data, addr);
  const txe = await (isSim ? client.callSim(payload) : client.call(payload));
  return callback(txe);
}
function linker(bytecode: string, name: string, address: string): string {
  address = address + Array(40 - address.length + 1).join('0');
  const truncated = name.slice(0, 36);
  const label = '__' + truncated + Array(37 - truncated.length).join('_') + '__';
  while (bytecode.indexOf(label) >= 0) {
    bytecode = bytecode.replace(label, address);
  }
  return bytecode;
}
export namespace Contract {
  export const abi =
    '[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"eventId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"intervalId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"eventAddress","type":"address"},{"indexed":false,"internalType":"string","name":"namespace","type":"string"},{"indexed":false,"internalType":"string","name":"name","type":"string"},{"indexed":false,"internalType":"address","name":"controller","type":"address"},{"indexed":false,"internalType":"uint256","name":"threshold","type":"uint256"},{"indexed":false,"internalType":"string","name":"metadata","type":"string"}],"name":"Init","type":"event"},{"constant":false,"inputs":[],"name":"announce","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"}]';
  export const bytecode =
    '6080604052348015600f57600080fd5b506102128061001f6000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80638f970df014610030575b600080fd5b61003861003a565b005b7f696e74657276616c3200000000000000000000000000000000000000000000007f6576656e743100000000000000000000000000000000000000000000000000007f5f20df97ee573ab8b43581cf3ff905f3507ad2329b7efe6f92e802b4fad031c17359c99d4ebf520619ee7f806f11d90a9cac02ce06336004604051808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001806020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184815260200180602001848103845260068152602001807f64696e696e670000000000000000000000000000000000000000000000000000815250602001848103835260098152602001807f627265616b666173740000000000000000000000000000000000000000000000815250602001848103825260178152602001807f6261636f6e2c6265616e732c656767732c746f6d61746f000000000000000000815250602001965050505050505060405180910390a356fea265627a7a723158202bd41fa5fa358aebac4419f707c61d5fc012d8362230234c07ba3481be69ae1464736f6c63430005110032';
  export function deploy(client: Provider): Promise<string> {
    const codec = client.contractCodec(abi);
    const linkedBytecode = bytecode;
    const data = Buffer.concat([Buffer.from(linkedBytecode, 'hex'), codec.encodeDeploy()]);
    const payload = client.payload(data);
    return client.deploy(payload);
  }
  export class Contract {
    private client: Provider;
    public address: string;
    constructor(client: Provider, address: string) {
      this.client = client;
      this.address = address;
    }
    Init(
      callback: (
        err?: Error | EndOfStream,
        eventName?: {
          eventId: Buffer;
          intervalId: Buffer;
          eventAddress: string;
          namespace: string;
          name: string;
          controller: string;
          threshold: number;
          metadata: string;
        },
      ) => void,
      range?: BlockRange,
    ): EventStream {
      return this.client.listen(
        '5F20DF97EE573AB8B43581CF3FF905F3507AD2329B7EFE6F92E802B4FAD031C1',
        this.address,
        (err?: Error | EndOfStream, log?: LogEvent) => {
          if (err) {
            return callback(err);
          }
          return callback(undefined, decode(this.client, log?.getData_asU8(), log?.getTopicsList_asU8()).Init());
        },
        range,
      );
    }
    announce(): Promise<void> {
      const data = encode(this.client).announce();
      return call<void>(this.client, this.address, data, false, (data: Uint8Array | undefined) => {
        return decode(this.client, data).announce();
      });
    }
  }
  export const encode = (client: Provider) => {
    const codec = client.contractCodec(abi);
    return {
      announce: () => {
        return codec.encodeFunctionData('8F970DF0');
      },
    };
  };
  export const decode = (client: Provider, data: Uint8Array | undefined, topics: Uint8Array[] = []) => {
    const codec = client.contractCodec(abi);
    return {
      Init: (): {
        eventId: Buffer;
        intervalId: Buffer;
        eventAddress: string;
        namespace: string;
        name: string;
        controller: string;
        threshold: number;
        metadata: string;
      } => {
        const [
          eventId,
          intervalId,
          eventAddress,
          namespace,
          name,
          controller,
          threshold,
          metadata,
        ] = codec.decodeEventLog('5F20DF97EE573AB8B43581CF3FF905F3507AD2329B7EFE6F92E802B4FAD031C1', data, topics);
        return {
          eventId: eventId,
          intervalId: intervalId,
          eventAddress: eventAddress,
          namespace: namespace,
          name: name,
          controller: controller,
          threshold: threshold,
          metadata: metadata,
        };
      },
      announce: (): void => {
        return;
      },
    };
  };
}
